#!/usr/bin/env bash
#
# kitty_overhaul.sh
# ------------------
# Refreshes the Kitty terminal experience: installs supporting tools, refreshes
# configuration, provides comfort-oriented defaults, and drops in smart kittens
# (including an AI helper hook). Run this as your regular user; the script will
# escalate with sudo when package installs are required.

set -euo pipefail

# ----- helpers ---------------------------------------------------------------

log() { printf '[kitty-overhaul] %s\n' "$*"; }

require() {
  local bin="$1"
  if ! command -v "$bin" >/dev/null 2>&1; then
    printf 'Error: required command %s not found. Install it first.\n' "$bin" >&2
    exit 1
  fi
}

backup_if_exists() {
  local file="$1"
  [[ -e "$file" ]] || return 0
  local stamp
  stamp="$(date +%Y%m%d%H%M%S)"
  cp -a "$file" "${file}.bak.${stamp}"
  log "Backup saved: ${file}.bak.${stamp}"
}

ensure_dir() {
  local dir="$1"
  if [[ ! -d "$dir" ]]; then
    mkdir -p "$dir"
    log "Created directory: $dir"
  fi
}

# ----- sanity checks --------------------------------------------------------

if [[ "$(id -u)" -eq 0 ]]; then
  printf 'Please run this script as a regular user (it will call sudo when needed).\n' >&2
  exit 1
fi

require sudo
require python3

sudo -v

# ----- package installs -----------------------------------------------------

APT_PACKAGES=(
  kitty
  kitty-terminfo
  fonts-jetbrains-mono
  ripgrep
  fd-find
  fzf
  bat
  btop
  tldr
  curl
  jq
  wl-clipboard
  xclip
  xsel
  python3-pip
  python3-requests
  python3-rich
)

log "Updating apt package index…"
sudo apt update -y

log "Installing Kitty ecosystem dependencies…"
sudo apt install -y "${APT_PACKAGES[@]}"

# Ensure bat is available as 'bat' (Debian-based systems ship batcat)
ensure_dir "${HOME}/.local/bin"
if command -v bat >/dev/null 2>&1; then
  log "'bat' already available."
else
  if command -v batcat >/dev/null 2>&1; then
    ln -sf "$(command -v batcat)" "${HOME}/.local/bin/bat"
    log "Symlinked bat -> batcat in ~/.local/bin (add to PATH if needed)."
  else
    log "Warning: bat/batcat not found even after install."
  fi
fi

log "Upgrading CLI helpers (aichat for AI assistant, tldr cache)…"
python3 -m pip install --user --upgrade aichat >/dev/null
tldr --update || true

# ----- Kitty configuration --------------------------------------------------

KITTY_DIR="${HOME}/.config/kitty"
KITTY_THEME_DIR="${KITTY_DIR}/themes"
KITTY_DEV_DIR="${KITTY_DIR}/dev/comfort-control-easehub"
KITTY_KITTENS_DIR="${KITTY_DIR}/kittens"
KITTY_SESSION_DIR="${KITTY_DIR}/sessions"

log "Refreshing Kitty configuration in ${KITTY_DIR}."
ensure_dir "$KITTY_DIR"
ensure_dir "$KITTY_THEME_DIR"
ensure_dir "$KITTY_DEV_DIR"
ensure_dir "$KITTY_KITTENS_DIR"
ensure_dir "$KITTY_SESSION_DIR"

backup_if_exists "${KITTY_DIR}/kitty.conf"
backup_if_exists "${KITTY_DIR}/smart.conf"
backup_if_exists "${KITTY_DIR}/sessions/dev-workbench.session"

log "Writing comfort-night theme."
cat <<'EOF' >"${KITTY_THEME_DIR}/comfort-night.conf"
# Comfort Night Theme (Catppuccin inspired)
background            #181926
foreground            #d9e0ee
selection_background  #2f3246
selection_foreground  #f5e0dc
cursor                #f2cdcd
cursor_text_color     #1a1826
url_color             #89dceb
active_border_color   #8aadf4
inactive_border_color #1f2233
active_tab_foreground #181926
active_tab_background #b7bdf8
inactive_tab_foreground #c6d0f5
inactive_tab_background #1e2030

color0  #09090f
color8  #575268
color1  #f38ba8
color9  #f7768e
color2  #a6e3a1
color10 #89dceb
color3  #f9e2af
color11 #f5c2e7
color4  #89b4fa
color12 #74c7ec
color5  #cba6f7
color13 #f2cdcd
color6  #94e2d5
color14 #94e2d5
color7  #cdd6f4
color15 #f4dbd6
EOF

log "Writing updated kitty.conf."
cat <<'EOF' >"${KITTY_DIR}/kitty.conf"
# Kitty comfort configuration generated by kitty_overhaul.sh

include themes/comfort-night.conf

font_family            JetBrainsMono Nerd Font
bold_font              auto
italic_font            auto
font_size              12.5
adjust_line_height     110%
cursor_shape           beam
cursor_blink_interval  0

scrollback_lines       20000
tab_bar_edge           top
tab_bar_style          powerline
tab_powerline_style    slanted
tab_bar_align          center
tab_bar_margin_height  4.0
tab_title_max_length   40

copy_on_select         yes
paste_with_middle_click yes
strip_trailing_spaces  smart
clipboard_control      write-clipboard write-primary
allow_remote_control   yes
listen_on              unix:@kitty-${USER}
shell_integration      enabled
detect_urls            yes
url_style              double
url_color              #89dceb
enable_audio_bell      no
visual_bell_duration   0.08

background_opacity     0.93
dynamic_background_opacity yes
window_padding_width   6
window_margin_width    0
window_border_width    1
placement_strategy     most-recent
confirm_os_window_close 2

kitty_mod ctrl+shift

# Window / tab management
map kitty_mod+enter          new_window
map kitty_mod+t              new_tab
map kitty_mod+w              close_window
map kitty_mod+q              close_tab
map kitty_mod+right          next_tab
map kitty_mod+left           previous_tab
map kitty_mod+up             next_window
map kitty_mod+down           previous_window
map kitty_mod+shift+right    move_tab_forward
map kitty_mod+shift+left     move_tab_backward
map kitty_mod+f11            toggle_fullscreen
map kitty_mod+f12            toggle_maximized
map kitty_mod+f9             send_clear_all
map kitty_mod+f5             load_config_file
map kitty_mod+f2             edit_config_file

# Comfort keybindings
map kitty_mod+space          launch --type=overlay kitten smart_actions
map kitty_mod+f              launch --type=overlay kitten smart_actions search
map kitty_mod+p              launch --type=overlay kitten smart_actions project
map kitty_mod+g              launch --type=overlay kitten smart_actions git
map kitty_mod+b              launch --cwd=current btop
map kitty_mod+a              launch --type=overlay kitten ai_assist
map kitty_mod+d              detach_window keep-focus
map kitty_mod+o              launch --type=os-window --cwd=current

# Clipboard helpers
map kitty_mod+c              copy_to_clipboard
map kitty_mod+v              paste_from_clipboard
map kitty_mod+s              paste_from_selection
mouse_map shift+right press ungrabbed paste_from_clipboard
mouse_map ctrl+right press ungrabbed launch --type=overlay kitten hints
mouse_map right press ungrabbed launch --type=overlay kitten smart_actions

# Smart scrolling and search
map kitty_mod+slash          launch --type=overlay kitten smart_actions search
map kitty_mod+h              show_scrollback
map kitty_mod+backspace      change_font_size all 0
map kitty_mod+equal          change_font_size all +1.0
map kitty_mod+minus          change_font_size all -1.0

# Sessions
startup_session sessions/dev-workbench.session

# Performance tweaks
repaint_delay 8
input_delay   2
disable_ligatures never
cursor_stop_blinking_after 0
EOF

log "Writing default development session (devenv/windows)."
cat <<'EOF' >"${KITTY_SESSION_DIR}/dev-workbench.session"
# Kitty startup session generated by kitty_overhaul.sh
layout tall
cd ~/dev
launch zsh
launch --cwd ~/dev/clipflow-pro zsh
launch --cwd ~/dev zsh
EOF

# ----- kittens ---------------------------------------------------------------

log "Deploying upgraded smart_actions kitten."
cat <<'EOF' >"${KITTY_KITTENS_DIR}/smart_actions.py"
#!/usr/bin/env python3
"""
Smart actions kitten for Kitty.
Provides project search, quick open, git helpers, system tools, and AI shortcuts.
"""

from __future__ import annotations

import os
import shlex
import shutil
import subprocess
import sys
import textwrap
from typing import Callable, Dict, Iterable, List, Tuple


def find_command(*candidates: str) -> str | None:
    for name in candidates:
        if not name:
            continue
        path = shutil.which(name)
        if path:
            return path
    return None


FZF = find_command("fzf")
FD = find_command("fd", "fdfind")
RG = find_command("rg")
BAT = find_command("bat", "batcat")
NVIM = find_command("nvim", "vim")
LAZYGIT = find_command("lazygit")
BTOP = find_command("btop")
HTOP = find_command("htop")
KITTY_BIN = find_command("kitty")
EDITOR = os.environ.get("EDITOR") or NVIM or shutil.which("nano") or "nano"


def run_shell(command: str) -> int:
    return subprocess.run(command, shell=True, check=False).returncode


def run_cmd(cmd: Iterable[str]) -> int:
    return subprocess.run(list(cmd), check=False).returncode


def message(text: str) -> str:
    return textwrap.dedent(text).strip()


def ensure_directory(path: str) -> None:
    try:
        os.makedirs(path, exist_ok=True)
    except Exception:
        pass


def interactive_menu() -> str | None:
    options: List[Tuple[str, str]] = [
        ("search", "Search project files"),
        ("open", "Open file via editor/viewer"),
        ("git", "Git helper dashboard"),
        ("system", "System monitor / info"),
        ("ai", "AI assistant prompt"),
        ("project", "Project switcher / utilities"),
    ]

    if FZF:
        menu_text = "\n".join(f"{key}\t{label}" for key, label in options)
        proc = subprocess.run(
            [FZF, "--prompt=Kitty ▶ ", "--with-nth=2", "--ansi"],
            input=menu_text,
            text=True,
            capture_output=True,
            check=False,
        )
        if proc.returncode != 0 or not proc.stdout.strip():
            return None
        return proc.stdout.split("\t", 1)[0].strip()

    print("Select action:")
    for idx, (_, label) in enumerate(options, start=1):
        print(f" {idx}. {label}")
    try:
        choice = input("Choice> ").strip()
    except KeyboardInterrupt:
        return None
    if not choice:
        return None
    if choice.isdigit() and 1 <= int(choice) <= len(options):
        return options[int(choice) - 1][0]
    for key, label in options:
        if choice.lower() in {key.lower(), label.lower()}:
            return key
    return None


def ensure_tools(*names: str) -> str | None:
    missing = [name for name in names if not find_command(name)]
    if missing:
        return message(
            f"Install {'/'.join(missing)} for this action "
            "(kitty_overhaul.sh attempted to install them)."
        )
    return None


def action_search(args: List[str]) -> str:
    if FD and FZF:
        preview = (
            f"{BAT or 'cat'} --style=plain --pager=never --color=always {{}}"
            if BAT
            else "sed -n '1,160p' {}"
        )
        command = (
            f"{FD} --type file --hidden --follow --exclude .git "
            f"| {FZF} --ansi --preview '{preview}' "
            "--prompt 'Search ▶ ' --bind 'enter:execute-silent(kitty @ launch --type=overlay --cwd=current "
            "kitten smart_actions open {+})'"
        )
        run_shell(command)
        return "Interactive search launched."

    if RG:
        query = " ".join(args) if args else ""
        if not query:
            return "Pass a pattern: kitten smart_actions search <pattern>"
        run_cmd([RG, "--smart-case", query])
        return f"Searched for '{query}'."

    return ensure_tools("fd", "fdfind", "rg") or "Search utilities unavailable."


def action_open(args: List[str]) -> str:
    if not args:
        return "Usage: kitten smart_actions open <path>"
    target = os.path.abspath(args[0])
    if not os.path.exists(target):
        return f"File not found: {target}"

    if os.path.isdir(target):
        run_cmd([KITTY_BIN or "kitty", "@", "launch", "--type=tab", "--cwd", target])
        return f"Opened directory in new tab: {target}"

    ext = os.path.splitext(target)[1].lower()
    if ext in {".png", ".jpg", ".jpeg", ".gif", ".bmp", ".svg", ".pdf"}:
        run_cmd(["xdg-open", target])
        return f"Opening {target} with system viewer."

    run_cmd([EDITOR, target])
    return f"Opened {target} with {EDITOR}."


def action_git(args: List[str]) -> str:
    if LAZYGIT:
        run_cmd([LAZYGIT])
        return "Launched lazygit."

    ensure = ensure_tools("git")
    if ensure:
        return ensure

    if FZF:
        command = (
            "git status --short --branch "
            "| fzf --ansi --header='↕ pick file to view diff' "
            "--preview 'git diff --color=always -- {2}' "
        )
        run_shell(command)
        return "Git interactive status shown."

    run_shell("git status")
    return "Displayed git status."


def action_system(args: List[str]) -> str:
    monitor = BTOP or HTOP or find_command("top")
    if monitor:
        run_cmd([monitor])
        return f"Launched {os.path.basename(monitor)}."
    return "Install btop or htop for resource monitoring."


def action_ai(args: List[str]) -> str:
    if not KITTY_BIN:
        return "Kitty binary not found in PATH."
    cmd = [KITTY_BIN, "@", "launch", "--type=overlay", "kitten", "ai_assist"]
    if args:
        cmd.extend(args)
    run_cmd(cmd)
    return "AI assistant overlay invoked."


def projects_root() -> str:
    return os.path.expanduser(os.environ.get("PROJECTS_ROOT", "~/dev"))


def action_project(args: List[str]) -> str:
    root = projects_root()
    ensure_directory(root)
    if FZF and FD:
        command = (
            f"cd {shlex.quote(root)} && "
            f"{FD} --type directory --max-depth 3 --follow --hidden --exclude .git "
            "| sed 's#^./##' "
            "| sort "
            "| fzf --prompt 'Project ▶ ' "
            "--bind 'enter:execute-silent(kitty @ launch --type=os-window --cwd "
            f"{shlex.quote(root)}/{{}})'"
        )
        run_shell(command)
        return "Project chooser launched."

    entries = []
    for dirpath, dirnames, _ in os.walk(root):
        depth = dirpath[len(root):].count(os.sep)
        if depth > 2:
            dirnames[:] = []
            continue
        entries.append(dirpath)
    entries = sorted(entries)
    if not entries:
        return f"No projects found in {root}."
    print("Projects:")
    for idx, path in enumerate(entries, start=1):
        print(f"{idx:02d}. {path}")
    try:
        choice = input("Open project number> ").strip()
    except KeyboardInterrupt:
        return "Project selection cancelled."
    if choice.isdigit():
        idx = int(choice) - 1
        if 0 <= idx < len(entries):
            run_cmd([KITTY_BIN or "kitty", "@", "launch", "--type=os-window", "--cwd", entries[idx]])
            return f"Launched project window: {entries[idx]}"
    return "Project selection aborted."


ACTION_MAP: Dict[str, Callable[[List[str]], str]] = {
    "search": action_search,
    "open": action_open,
    "git": action_git,
    "system": action_system,
    "ai": action_ai,
    "project": action_project,
}


def main(args: List[str]) -> str:
    if not args:
        selection = interactive_menu()
        if not selection:
            return "No action selected."
        args = [selection]

    action = args[0]
    handler = ACTION_MAP.get(action)
    if not handler:
        return message(
            f"Unknown action '{action}'. "
            "Choices: search, open, git, system, ai, project."
        )

    return handler(args[1:])


if __name__ == "__main__":
    try:
        result = main(sys.argv[1:])
        if result:
            print(result)
    except KeyboardInterrupt:
        print("Cancelled.")
EOF
chmod 0755 "${KITTY_KITTENS_DIR}/smart_actions.py"

log "Adding AI assistant kitten hook."
cat <<'EOF' >"${KITTY_KITTENS_DIR}/ai_assist.py"
#!/usr/bin/env python3
"""
Minimal AI assistant launcher for Kitty.
Relies on an external CLI (default: aichat) and environment API keys.
"""

from __future__ import annotations

import os
import shlex
import shutil
import subprocess
import sys
import textwrap
from typing import List


def default_command() -> str:
    return os.environ.get("KITTY_AI_COMMAND", "aichat --no-stream")


def available_cli(bin_name: str) -> bool:
    return shutil.which(bin_name) is not None


def expand_command(command: str) -> List[str]:
    return shlex.split(command)


def ensure_api_token(env: dict) -> None:
    tokens = ["OPENAI_API_KEY", "AICHAT_API_KEY", "KITTY_AI_TOKEN"]
    if any(env.get(token) for token in tokens):
        return
    note = textwrap.dedent(
        """
        ⚠  No API key detected. Set one of OPENAI_API_KEY, AICHAT_API_KEY, or KITTY_AI_TOKEN.
        Example (OpenAI compatible providers):
            export OPENAI_API_KEY="sk-..."
        """
    ).strip()
    print(note)


def main(argv: List[str]) -> str:
    command = default_command()
    parts = expand_command(command)
    if not parts:
        return "Set KITTY_AI_COMMAND to point at your preferred AI CLI."
    binary = parts[0]
    if not available_cli(binary):
        return f"AI CLI '{binary}' not found. Install one (kitten installs aichat via pip)."

    prompt = " ".join(argv).strip()
    if not prompt:
        try:
            prompt = input("Prompt ▶ ").strip()
        except KeyboardInterrupt:
            return "AI request cancelled."
    if not prompt:
        return "Empty prompt: nothing to do."

    env = os.environ.copy()
    ensure_api_token(env)
    process = subprocess.run(parts, input=prompt, text=True, env=env)
    if process.returncode == 0:
        return "AI assistant completed."
    return f"AI assistant exited with status {process.returncode}."


if __name__ == "__main__":
    try:
        outcome = main(sys.argv[1:])
        if outcome:
            print(outcome)
    except KeyboardInterrupt:
        print("Cancelled.")
EOF
chmod 0755 "${KITTY_KITTENS_DIR}/ai_assist.py"

# ----- README / guidance -----------------------------------------------------

log "Dropping quickstart guide."
cat <<'EOF' >"${KITTY_DEV_DIR}/README.txt"
Kitty Comfort Control & Ease Hub
================================

Key bindings (Ctrl+Shift = kitty_mod):
  Ctrl+Shift+Space  → smart actions hub (fzf menu)
  Ctrl+Shift+F      → project file search
  Ctrl+Shift+G      → git helper
  Ctrl+Shift+A      → AI assistant overlay (requires API key + aichat)
  Ctrl+Shift+B      → btop system monitor
  Ctrl+Shift+Enter  → split window / new shell
  Right click       → smart actions hub
  Shift + Right     → paste from clipboard
  Ctrl  + Right     → launch kitty hints (URL selector)

AI assistant:
  • Default CLI is `aichat` (installed via pip --user).
  • Configure provider by setting environment variables, e.g.
        export OPENAI_API_KEY="sk-..."
        export KITTY_AI_COMMAND="aichat --no-stream --model gpt-4o-mini"

Project root:
  • Adjust $PROJECTS_ROOT (defaults to ~/dev) to change directories surfaced by
    the project switcher.

Session file:
  • Edit ~/.config/kitty/sessions/dev-workbench.session to customise the
    default windows/tabs on launch.

You can re-run kitty_overhaul.sh at any time; it will snapshot existing config
files before rewriting them.
EOF

log "Installing shared API key loader."
cat <<'EOF' >"${KITTY_DIR}/load-api-keys.sh"
#!/usr/bin/env bash
# Auto-generated by kitty_overhaul.sh. Do not edit in-place; customise myapikeys.txt instead.

kitty_load_api_keys() {
  local refresh_only=0
  if [[ "${1:-}" == "--refresh-only" ]]; then
    refresh_only=1
  fi

  local source_file="${API_KEY_SOURCE:-${HOME}/Desktop/myapikeys.txt}"
  local export_file="${API_KEY_EXPORT:-${HOME}/.config/kitty/api-keys.env}"

  if [[ -f "${source_file}" ]]; then
    if [[ ! -f "${export_file}" || "${source_file}" -nt "${export_file}" ]]; then
      API_KEY_SOURCE="${source_file}" API_KEY_EXPORT="${export_file}" python3 <<'PY'
import os, re, shlex, pathlib
source = pathlib.Path(os.environ['API_KEY_SOURCE'])
dest = pathlib.Path(os.environ['API_KEY_EXPORT'])
dest.parent.mkdir(parents=True, exist_ok=True)
lines = source.read_text().splitlines()
exports = []
mapping = {
    'OPENAI': 'OPENAI_API_KEY',
    'CHATGPT_OPENAI': 'OPENAI_API_KEY',
    'CHATGPT': 'OPENAI_API_KEY',
    'OPENAI_API': 'OPENAI_API_KEY',
    'OPENAI_KEY': 'OPENAI_API_KEY',
    'OPENAI_SECRET': 'OPENAI_API_KEY',
    'OPENAI_API_KEY': 'OPENAI_API_KEY',
    'GROQ': 'GROQ_API_KEY',
    'GROQ_API_KEY': 'GROQ_API_KEY',
    'ANTHROPIC': 'ANTHROPIC_API_KEY',
    'ANTHROPIC_API_KEY': 'ANTHROPIC_API_KEY',
    'GOOGLE': 'GOOGLE_API_KEY',
    'GOOGLE_GEMINI': 'GOOGLE_API_KEY',
    'GEMINI': 'GOOGLE_API_KEY',
    'GEMINI_API_KEY': 'GOOGLE_API_KEY',
    'MISTRAL': 'MISTRAL_API_KEY',
    'MISTRAL_API_KEY': 'MISTRAL_API_KEY',
    'DEEPSEEK': 'DEEPSEEK_API_KEY',
    'DEEPSEEK_API_KEY': 'DEEPSEEK_API_KEY',
}
for raw in lines:
    line = raw.strip()
    if not line or line.startswith('#'):
        continue
    if ':' in line:
        key, value = line.split(':', 1)
    elif '=' in line:
        key, value = line.split('=', 1)
    else:
        continue
    key_upper = re.sub(r'[^A-Za-z0-9]+', '_', key.strip()).strip('_').upper()
    env_key = mapping.get(key_upper, key_upper)
    value = value.strip()
    if not value:
        continue
    exports.append((env_key, shlex.quote(value)))
with dest.open('w') as fh:
    fh.write('# Auto-generated exports\n')
    for env_key, quoted in exports:
        fh.write(f'export {env_key}={quoted}\n')
PY
    fi

    if [[ "${refresh_only}" -eq 0 && -f "${export_file}" ]]; then
      set -a
      # shellcheck disable=SC1090
      source "${export_file}"
      set +a
    fi
  fi

  if [[ "${refresh_only}" -eq 0 ]]; then
    if [[ -z "${KITTY_AI_COMMAND:-}" ]]; then
      if command -v ollama >/dev/null 2>&1; then
        export KITTY_AI_COMMAND="aichat --no-stream --model ollama/llama3 --endpoint http://localhost:11434"
      else
        export KITTY_AI_COMMAND="aichat --no-stream"
      fi
    fi

    if [[ -d "${HOME}/.local/bin" && ":${PATH}:" != *":${HOME}/.local/bin:"* ]]; then
      export PATH="${HOME}/.local/bin:${PATH}"
    fi
  fi
}

kitty_load_api_keys "$@"
unset -f kitty_load_api_keys
return 0 2>/dev/null || exit 0
EOF
chmod 0755 "${KITTY_DIR}/load-api-keys.sh"

# ----- completion ------------------------------------------------------------

log "All tasks complete."
cat <<'EOF'

Next steps:
  1. Restart Kitty (or press Ctrl+Shift+F5 inside Kitty to reload config).
  2. Ensure ~/.local/bin is on your PATH for the bat wrapper.
  3. Set AI API keys if you plan to use the assistant (see README in
     ~/.config/kitty/dev/comfort-control-easehub/README.txt).

Happy hacking! 🐱
EOF
